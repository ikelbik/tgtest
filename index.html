<!DOCTYPE html>
<html>
<head>
    <meta name="telegram:verify" content="VERIFICATION_CODE_OT_BOTFATHER">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">	
    <link rel="manifest" href="https://ikelbik.github.io/tgtest/app-manifest.json">
    <link rel="icon" type="image/png" href="https://ikelbik.github.io/tgtest/favicon.png">    
    <meta charset="UTF-8">
    <meta name="theme-color" content="#000022">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; touch-action: none }
        body { background: #000022 }
        html, body, #game-container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }		
    </style>
</head>
<body>
    <div id="game"></div>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        const tg = window.Telegram?.WebApp;
        
        if (tg) {
            tg.ready();
            tg.expand();
        }

        class LoadScene extends Phaser.Scene {
            constructor() {
                super({ key: 'LoadScene' });
                this.loadProgress = 0;
                this.isLoading = true;
            }

            init() {
                this.cameras.main.setBackgroundColor('#000022');
                
                this.load.on('progress', (value) => {
                    this.loadProgress = value;
                    this.updateProgressBar();
                });
                
                this.load.on('filecomplete', (key) => {
                    if (key === 'loadscreen' && !this.bg) {
                        this.showLoadScreen();
                    }
                });
                
                this.load.on('complete', () => {
                    this.isLoading = false;
                    this.time.delayedCall(500, () => {
                        this.showPlayButton();
                    });
                });
            }

            preload() {
                this.load.setBaseURL('https://ikelbik.github.io/tgtest');
                
                this.load.image('loadscreen', 'assets/loadscreen.jpg');
                this.load.image('bg', 'assets/bg00.jpg');
                this.load.image('menu_btn', 'assets/coin_t0.png');
                this.load.audio('menuClick', 'assets/up.mp3');
                this.load.atlas('flares', 'assets/flares.png', 'assets/flares.json');
            }

            showLoadScreen() {
                this.bg = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'loadscreen');
                
                const scaleX = this.cameras.main.width / this.bg.width;
                const scaleY = this.cameras.main.height / this.bg.height;
                const scale = Math.max(scaleX, scaleY);
                this.bg.setScale(scale);

                this.createProgressBarUI();
            }

            createProgressBarUI() {
                this.createProgressBar();
                
                this.loadingText = this.add.text(this.cameras.main.centerX, this.cameras.main.height - 200, 
                    'Загрузка...', {
                    font: '28px Arial',
                    fill: '#ffffff',
                    align: 'center'
                }).setOrigin(0.5);
            }

            create() {
                if (!this.bg) {
                    this.time.delayedCall(100, () => {
                        if (this.textures.exists('loadscreen')) {
                            this.showLoadScreen();
                        } else {
                            this.bg = this.add.rectangle(this.cameras.main.centerX, this.cameras.main.centerY, 
                                                       this.cameras.main.width, this.cameras.main.height, 0x000044);
                            this.createProgressBarUI();
                        }
                    });
                }
            }

            createProgressBar() {
                const barWidth = 300;
                const barHeight = 20;
                const x = this.cameras.main.centerX - barWidth / 2;
                const y = this.cameras.main.height - 250;

                this.progressBg = this.add.graphics();
                this.progressBg.fillStyle(0x222222, 0.8);
                this.progressBg.fillRoundedRect(x, y, barWidth, barHeight, 10);
                
                this.progressBorder = this.add.graphics();
                this.progressBorder.lineStyle(2, 0xffffff, 0.8);
                this.progressBorder.strokeRoundedRect(x, y, barWidth, barHeight, 10);

                this.progressBar = this.add.graphics();
                
                this.percentText = this.add.text(this.cameras.main.centerX, y + barHeight / 2, '0%', {
                    font: '16px Arial',
                    fill: '#ffffff'
                }).setOrigin(0.5);
            }

            updateProgressBar() {
                if (!this.progressBar) return;
                
                const barWidth = 300;
                const barHeight = 20;
                const x = this.cameras.main.centerX - barWidth / 2;
                const y = this.cameras.main.height - 250;
                
                this.progressBar.clear();
                
                const progress = this.loadProgress;
                const fillWidth = barWidth * progress;
                
                if (fillWidth > 0) {
                    const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                        { r: 100, g: 150, b: 255 },
                        { r: 100, g: 255, b: 100 },
                        100,
                        Math.floor(progress * 100)
                    );
                    
                    this.progressBar.fillStyle(Phaser.Display.Color.GetColor(color.r, color.g, color.b));
                    this.progressBar.fillRoundedRect(x, y, fillWidth, barHeight, 10);
                }
                
                if (this.percentText) {
                    this.percentText.setText(Math.floor(progress * 100) + '%');
                }
                
                if (this.loadingText) {
                    if (progress < 1) {
                        this.loadingText.setText('Загрузка... ' + Math.floor(progress * 100) + '%');
                    } else {
                        this.loadingText.setText('Загрузка завершена!');
                    }
                }
            }

            showPlayButton() {
                this.progressBg.setVisible(false);
                this.progressBorder.setVisible(false);
                this.progressBar.setVisible(false);
                this.percentText.setVisible(false);
                this.loadingText.setVisible(false);
                
                this.scene.start('MenuScene');
            }
        }

        class MenuScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MenuScene' });
                this.particles = [];
            }

            create() {
                this.cameras.main.setBackgroundColor('#000022');
                
                // Создаем фоновый градиент
                this.createBackground();
                
                // Создаем частицы для атмосферы
                this.createBackgroundParticles();
                
                // Заголовок с анимацией
                this.createTitle();
                
                // Создаем кнопки меню
                this.createMenuButtons();
                
                // Скрываем кнопку Telegram
                if (window.Telegram?.WebApp) {
                    window.Telegram.WebApp.MainButton.hide();
                }
            }
            
            createBackground() {
                // Создаем градиентный фон
                const graphics = this.add.graphics();
                
                // Создаем радиальный градиент
                const centerX = this.cameras.main.centerX;
                const centerY = this.cameras.main.centerY;
                const radius = Math.max(this.cameras.main.width, this.cameras.main.height);
                
                for (let i = 0; i < radius; i += 10) {
                    const alpha = 1 - (i / radius) * 0.8;
                    const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                        { r: 20, g: 30, b: 80 },
                        { r: 0, g: 0, b: 34 },
                        100,
                        Math.floor((i / radius) * 100)
                    );
                    
                    graphics.fillStyle(Phaser.Display.Color.GetColor(color.r, color.g, color.b), alpha);
                    graphics.fillCircle(centerX, centerY, radius - i);
                }
            }
            
            createBackgroundParticles() {
                // Создаем плавающие частицы для атмосферы
                for (let i = 0; i < 20; i++) {
                    const particle = this.add.circle(
                        Phaser.Math.Between(0, this.cameras.main.width),
                        Phaser.Math.Between(0, this.cameras.main.height),
                        Phaser.Math.Between(2, 6),
                        0x4a6fff,
                        0.3
                    );
                    
                    // Анимация плавного движения
                    this.tweens.add({
                        targets: particle,
                        y: particle.y + Phaser.Math.Between(-100, 100),
                        x: particle.x + Phaser.Math.Between(-50, 50),
                        alpha: { from: 0.1, to: 0.5 },
                        duration: Phaser.Math.Between(3000, 6000),
                        ease: 'Sine.easeInOut',
                        yoyo: true,
                        repeat: -1,
                        delay: Phaser.Math.Between(0, 2000)
                    });
                }
            }
            
            createTitle() {
                const title = this.add.text(this.cameras.main.centerX, 200, 'CRYPTO GAME', { 
                    fontSize: '52px', 
                    fill: '#4a6fff',
                    fontStyle: 'bold',
                    stroke: '#000044',
                    strokeThickness: 6,
                    shadow: {
                        offsetX: 3,
                        offsetY: 3,
                        color: '#000000',
                        blur: 10,
                        fill: true
                    }
                }).setOrigin(0.5);
                
                // Пульсирующая анимация заголовка
                this.tweens.add({
                    targets: title,
                    scale: { from: 1, to: 1.1 },
                    duration: 2000,
                    ease: 'Sine.easeInOut',
                    yoyo: true,
                    repeat: -1
                });
                
                // Анимация появления
                title.setAlpha(0);
                this.tweens.add({
                    targets: title,
                    alpha: 1,
                    duration: 1000,
                    ease: 'Power2.easeOut'
                });
            }
            
            createMenuButtons() {
                const buttonWidth = 280;
                const buttonHeight = 90;
                const spacing = 40;
                const startY = this.cameras.main.centerY - 80;
                
                const buttonLabels = [
                    { text: '🎮 Фарминг', page: 'farming.html', icon: '⛏️' },
                    { text: '🔒 Сейфы', page: 'safes.html', icon: '💎' },
                    { text: '💰 Кошелек', page: 'wallet.html', icon: '💰' },
                    { text: '👤 Профиль', page: 'profile.html', icon: '⭐' }
                ];
                
                this.menuClickSound = this.sound.add('menuClick', { volume: 0.5 });
                
                this.buttons = [];
                for (let i = 0; i < buttonLabels.length; i++) {
                    const buttonContainer = this.add.container(
                        this.cameras.main.centerX, 
                        startY + i * (buttonHeight + spacing)
                    );
                    
                    // Создаем фон кнопки с градиентом
                    const buttonBg = this.add.graphics();
                    buttonBg.fillGradientStyle(0x2a4fff, 0x2a4fff, 0x1a3eee, 0x1a3eee, 1);
                    buttonBg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 20);
                    buttonBg.lineStyle(3, 0x4a6fff, 0.8);
                    buttonBg.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 20);
                    
                    // Создаем эффект свечения
                    const glow = this.add.graphics();
                    glow.fillStyle(0x4a6fff, 0.3);
                    glow.fillRoundedRect(-buttonWidth/2 - 5, -buttonHeight/2 - 5, buttonWidth + 10, buttonHeight + 10, 25);
                    glow.setVisible(false);
                    
                    // Иконка
                    const icon = this.add.text(-60, 0, buttonLabels[i].icon, {
                        font: '36px Arial',
                        fill: '#ffffff'
                    }).setOrigin(0.5);
                    
                    // Текст кнопки
                    const text = this.add.text(20, 0, buttonLabels[i].text, { 
                        font: '28px Arial', 
                        fill: '#ffffff',
                        stroke: '#000044',
                        strokeThickness: 3,
                        fontStyle: 'bold'
                    }).setOrigin(0.5);
                    
                    buttonContainer.add([glow, buttonBg, icon, text]);
                    
                    // Делаем кнопку интерактивной
                    const hitArea = new Phaser.Geom.Rectangle(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight);
                    buttonContainer.setInteractive(hitArea, Phaser.Geom.Rectangle.Contains);
                    buttonContainer.setData('page', buttonLabels[i].page);
                    
                    // Эффекты при наведении
                    buttonContainer.on('pointerover', () => {
                        this.tweens.add({
                            targets: buttonContainer,
                            scale: 1.05,
                            duration: 200,
                            ease: 'Back.easeOut'
                        });
                        
                        glow.setVisible(true);
                        this.tweens.add({
                            targets: glow,
                            alpha: { from: 0, to: 0.6 },
                            duration: 200
                        });
                        
                        // Эффект пульсации иконки
                        this.tweens.add({
                            targets: icon,
                            scale: { from: 1, to: 1.2 },
                            duration: 300,
                            ease: 'Sine.easeInOut',
                            yoyo: true
                        });
                    });
                    
                    buttonContainer.on('pointerout', () => {
                        this.tweens.add({
                            targets: buttonContainer,
                            scale: 1,
                            duration: 200,
                            ease: 'Back.easeOut'
                        });
                        
                        this.tweens.add({
                            targets: glow,
                            alpha: 0,
                            duration: 200,
                            onComplete: () => glow.setVisible(false)
                        });
                        
                        this.tweens.add({
                            targets: icon,
                            scale: 1,
                            duration: 200
                        });
                    });
                    
                    buttonContainer.on('pointerdown', () => {
                        this.menuClickSound.play();
                        
                        // Эффект нажатия
                        this.tweens.add({
                            targets: buttonContainer,
                            scale: 0.95,
                            duration: 100,
                            ease: 'Power2.easeOut',
                            yoyo: true,
                            onComplete: () => {
                                // Эффект частиц при клике
                                this.createClickParticles(buttonContainer.x, buttonContainer.y);
                                
                                // Переход на страницу
                                const page = buttonContainer.getData('page');
                                window.location.href = page;
                            }
                        });
                        
                        // Вспышка
                        const flash = this.add.circle(0, 0, buttonWidth/2, 0xffffff, 0.8);
                        buttonContainer.add(flash);
                        this.tweens.add({
                            targets: flash,
                            scale: { from: 0, to: 2 },
                            alpha: { from: 0.8, to: 0 },
                            duration: 400,
                            onComplete: () => flash.destroy()
                        });
                    });
                    
                    // Анимация появления
                    buttonContainer.setAlpha(0);
                    buttonContainer.y += 100;
                    this.tweens.add({
                        targets: buttonContainer,
                        y: startY + i * (buttonHeight + spacing),
                        alpha: 1,
                        duration: 600,
                        delay: i * 150,
                        ease: 'Back.easeOut'
                    });
                    
                    this.buttons.push(buttonContainer);
                }
            }
            
            createClickParticles(x, y) {
                if (this.textures.exists('flares')) {
                    const particles = this.add.particles(x, y, 'flares', {
                        frame: { frames: ['white', 'yellow', 'blue'], cycle: true },
                        blendMode: 'ADD',
                        lifespan: { min: 200, max: 500 },
                        speed: { min: 50, max: 150 },
                        quantity: 10,
                        scale: { start: 0.8, end: 0 },
                        alpha: { start: 0.8, end: 0 }
                    });
                    
                    this.time.delayedCall(500, () => {
                        particles.destroy();
                    });
                }
            }
        }
        
        const config = {
            type: Phaser.WEBGL,
            parent: 'game',
            scene: [LoadScene, MenuScene],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1024,
                height: 1920,
                resolution: Math.max(window.devicePixelRatio || 1, 1),
            },
            input: { 
                activePointers: 2 
            },
            fps: { 
                target: 60,
                smoothStep: true 
            },
            render: { 
                antialiasGL: true,
                pixelArt: false
            }
        };

        if (navigator.userAgent.toLowerCase().includes('android')) {
            document.body.style.height = `${window.innerHeight}px`;
            setTimeout(() => {
                document.body.style.height = `${window.innerHeight}px`;
            }, 1000);
        }	   
        
        setTimeout(() => {
            const game = new Phaser.Game(config);
            window.addEventListener('resize', () => {
                if (game && game.scale) {
                    game.scale.refresh();
                }
            });
        }, 300);
        
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>