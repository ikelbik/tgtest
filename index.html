<!DOCTYPE html>
<html>
<head>
	<meta name="telegram:verify" content="VERIFICATION_CODE_OT_BOTFATHER">
	<link rel="manifest" href="/app-manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000022">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        *{margin:0;padding:0;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:none}
        body{background:#000022}
    </style>
</head>
<body>
    <div id="game"></div>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
  const isTelegram = /Telegram/.test(navigator.userAgent);
  const tg = window.Telegram.WebApp;
  tg.expand(); // Раскрыть на весь экран
  tg.MainButton.show(); // Показать основную кнопку
  
class MainScene extends Phaser.Scene {
    constructor(){
        super();
        this.rotSpeed = isTelegram ? 0.005 : 0.01;
        this.scaleFactor = isTelegram ? 0.0005 : 0.001;
        this.isDragging = false;
        this.isScaling = false;
        this.prevX = 0;
        this.prevY = 0;
        this.initDist = 0;
        this.initScale = 1;
    }

    preload(){
        this.load.setBaseURL('https://ikelbik.github.io/tgtest');
        this.load.image('bg','assets/wtf.png');
        this.load.obj('skull','assets/fantom.obj');
        this.load.image('texture','assets/coin_txt.png');
    }

    create(){
        if(isTelegram && window.TelegramWebViewProxy){
            TelegramWebViewProxy.onEvent('back_button',()=>this.scene.stop());
            Telegram.WebApp.expand();
        }

        this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'bg');
        this.mesh = this.add.mesh(this.cameras.main.centerX, this.cameras.main.centerY, 'texture');
        this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'bg');
        this.mesh = this.add.mesh(this.cameras.main.centerX, this.cameras.main.centerY, 'texture');
        this.mesh.addVerticesFromObj('skull',0.1).panZ(7).modelRotation.y +=0.5;
		//this.mesh.addVerticesFromObj('skull',0.1);
		this.mesh.panX(this.cameras.main.centerX-0);
		//this.mesh.panY(this.cameras.main.centerY);
		//this.mesh.panZ(7);
		this.mesh.modelRotation.x += 0.5;

        
        this.mesh.setInteractive(new Phaser.Geom.Rectangle(-200,-200,400,400),Phaser.Geom.Rectangle.Contains);
        
        this.mesh.on('pointerdown',p=>{
            if(p.event.touches?.length>=2){
                const[t1,t2]=p.event.touches;
                this.initDist=Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);
                this.initScale=this.mesh.scaleX;
                this.isScaling=true;
            }else{
                this.isDragging=true;
                [this.prevX,this.prevY]=[p.x,p.y];
            }
        });

        this.input.on('pointermove',p=>{
            if(!p.isDown) return;
            if(p.event.touches?.length>=2){
                const[t1,t2]=p.event.touches;
                const dist=Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);
                this.mesh.setScale(Phaser.Math.Clamp(this.initScale*(dist/this.initDist),0.3,10));
            }else if(this.isDragging){
                const dx=p.x-this.prevX, dy=p.y-this.prevY;
                this.mesh.modelRotation.y += dx*this.rotSpeed;
                this.mesh.modelRotation.x += dy*this.rotSpeed;
                [this.prevX,this.prevY]=[p.x,p.y];
            }
        });

        this.input.on('pointerup',()=>this.isDragging=this.isScaling=false);
        
        this.input.on('wheel',(_,__,___,dy)=>{
            this.mesh.setScale(Phaser.Math.Clamp(this.mesh.scaleX+dy*-this.scaleFactor,0.3,10));
        });

        this.scale.on('resize',s=>{
            this.cameras.main.setSize(s.width,s.height);
            this.mesh.setPosition(s.width/2,s.height/2);
        });

        if(this.sys.game.device.input.touch) this.input.addTouchLock();
    }
}

const config = {
    type: Phaser.WEBGL,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game',
    scene: MainScene,
	    type: Phaser.WEBGL,
    parent: 'game',
    scene: MainScene,
    render: {
        antialias: true,
        antialiasGL: true,
        powerPreference: "high-performance"
    },
    cameras: {
        default: {
          //  type: 'OrthographicCamera',
            zoom: 1,
            multisampleLevel: 4,
            antialias: true
        }
    },
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    input: { activePointers:3, touch:{capture:true} },
    fps: { target:60, smoothStep:true },

};

new Phaser.Game(config);
window.addEventListener('resize',()=>game.scale.resize(window.innerWidth,window.innerHeight));
document.addEventListener('contextmenu',e=>e.preventDefault());
</script>
</body>
</html>