<!DOCTYPE html>
<html>
<head>
    <meta name="telegram:verify" content="VERIFICATION_CODE_OT_BOTFATHER">
    <link rel="manifest" href="/app-manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000022">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        *{margin:0;padding:0;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:none}
        body{background:#000022}
    </style>
</head>
<body>
    <div id="game"></div>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
  const isTelegram = /Telegram/.test(navigator.userAgent);
  const tg = window.Telegram.WebApp;
  tg.expand();
  tg.MainButton.show();
  
class MainScene extends Phaser.Scene {
    constructor(){
        super();
        this.rotSpeed = isTelegram ? 0.005 : 0.01;
        this.scaleFactor = isTelegram ? 0.0005 : 0.001;
        this.isDragging = false;
        this.isScaling = false;
        this.prevX = 0;
        this.prevY = 0;
        this.initDist = 0;
        this.initScale = 1;
    }

    preload(){
        this.load.setBaseURL('https://ikelbik.github.io/tgtest');
        this.load.image('bg','assets/wtf.png');
        this.load.obj('skull','assets/fantom.obj');
        this.load.image('texture','assets/coin_txt.png');
    }

    create(){
        if(isTelegram && window.TelegramWebViewProxy){
            TelegramWebViewProxy.onEvent('back_button',()=>this.scene.stop());
            Telegram.WebApp.expand();
        }

        const {width, height} = this.cameras.main;
        this.add.image(width/2, height/2, 'bg');
        
        // Создаем контейнер для стопки монет
        this.coinStack = this.add.mesh(width/2, height/2);
        
        // Создаем 10 монет с смещением
        for(let i = 0; i < 10; i++) {
            const coin = this.add.mesh(0, 0, 'texture')
                .addVerticesFromObj('skull', 0.1)
                .panZ(7 + i * 0.5)
                .panY(i * 0.3)
                .setDepth(i);
            
            coin.modelRotation.y += 0.5;
            this.coinStack.add(coin);
        }

        // Настройка интерактивной области
        const interactiveSize = 400;
        this.coinStack.setInteractive(
            new Phaser.Geom.Rectangle(
                -interactiveSize/2, 
                -interactiveSize/2, 
                interactiveSize, 
                interactiveSize
            ), 
            Phaser.Geom.Rectangle.Contains
        );

        // Обработчики событий
        this.coinStack.on('pointerdown', (p) => {
            if(p.event.touches?.length >= 2){
                const [t1, t2] = p.event.touches;
                this.initDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                this.initScale = this.coinStack.scaleX;
                this.isScaling = true;
            } else {
                this.isDragging = true;
                [this.prevX, this.prevY] = [p.x, p.y];
            }
        });

        this.input.on('pointermove', (p) => {
            if(!p.isDown) return;
            
            if(p.event.touches?.length >= 2){
                const [t1, t2] = p.event.touches;
                const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                const newScale = Phaser.Math.Clamp(this.initScale * (dist / this.initDist), 0.3, 10);
                this.coinStack.setScale(newScale);
            } else if(this.isDragging) {
                const dx = p.x - this.prevX;
                const dy = p.y - this.prevY;
                this.coinStack.modelRotation.y += dx * this.rotSpeed;
                this.coinStack.modelRotation.x += dy * this.rotSpeed;
                [this.prevX, this.prevY] = [p.x, p.y];
            }
        });

        this.input.on('pointerup', () => {
            this.isDragging = false;
            this.isScaling = false;
        });

        this.input.on('wheel', (_, __, ___, dy) => {
            const newScale = Phaser.Math.Clamp(
                this.coinStack.scaleX + dy * -this.scaleFactor, 
                0.3, 
                10
            );
            this.coinStack.setScale(newScale);
        });

        // Обработчик изменения размера экрана
        this.scale.on('resize', (gameSize) => {
            this.cameras.main.setSize(gameSize.width, gameSize.height);
            this.coinStack.setPosition(gameSize.width/2, gameSize.height/2);
        });

        if(this.sys.game.device.input.touch) {
            this.input.addTouchLock();
        }
    }
}

const config = {
    type: Phaser.WEBGL,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game',
    scene: MainScene,
    scale: { 
        mode: Phaser.Scale.RESIZE, 
        autoCenter: Phaser.Scale.CENTER_BOTH 
    },
    input: { 
        activePointers: 3,
        touch: { capture: true } 
    },
    fps: { 
        target: 60,
        smoothStep: true 
    },
    render: { 
        antialiasGL: false 
    }
};

const game = new Phaser.Game(config);

window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});

document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
});
</script>
</body>
</html>