<!DOCTYPE html>
<html>
<head>
    <meta name="telegram:verify" content="VERIFICATION_CODE_OT_BOTFATHER">
    <link rel="manifest" href="/app-manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000022">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        *{margin:0;padding:0;overflow:hidden;-webkit-tap-highlight-color:transparent;touch-action:none}
        body{background:#000022}
    </style>
</head>
<body>
    <div id="game"></div>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
  const isTelegram = /Telegram/.test(navigator.userAgent);
  const tg = window.Telegram.WebApp;
  tg.expand();
  tg.MainButton.show();
  
class MainScene extends Phaser.Scene {
    constructor(){
        super();
        this.rotSpeed = isTelegram ? 0.005 : 0.01;
        this.scaleFactor = isTelegram ? 0.0005 : 0.001;
        this.isDragging = false;
        this.isScaling = false;
        this.prevX = 0;
        this.prevY = 0;
        this.initDist = 0;
        this.initScale = 1;
    }

    preload(){
        this.load.setBaseURL('https://ikelbik.github.io/tgtest');
        this.load.image('bg','assets/wtf.png');
        this.load.obj('skull','assets/fantom.obj');
        this.load.image('texture','assets/coin_txt.png');
    }

    create(){
        if(isTelegram && window.TelegramWebViewProxy){
            TelegramWebViewProxy.onEvent('back_button',()=>this.scene.stop());
            Telegram.WebApp.expand();
        }

        this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'bg');
        
        // Создаем родительский контейнер для стопки монет
        // Создаем родительский контейнер с правильным позиционированием
        this.coinStack = this.add.mesh(
            this.cameras.main.centerX, 
            this.cameras.main.centerY, 
            'texture'
        ).setDepth(1);
        
            // Создаем 10 монет с учетом правильного позиционирования
        for(let i = 0; i < 10; i++) {
            const coin = this.add.mesh(0, 0, 'texture')
                .addVerticesFromObj('skull', 0.1)
                .panZ(7 + i * 0.5)
                .panY(i * 0.3)
                .setDepth(i); // Устанавливаем глубину для правильного отображения
            
            coin.modelRotation.y += 0.5;
            this.coinStack.add(coin);
        }

        // Настраиваем интерактивную область с учетом стопки
        const interactiveSize = 400 * Math.max(this.coinStack.scaleX, 1);
        this.coinStack.setInteractive(
            new Phaser.Geom.Rectangle(
                -interactiveSize/2, 
                -interactiveSize/2, 
                interactiveSize, 
                interactiveSize
            ), 
            Phaser.Geom.Rectangle.Contains
        );

        this.input.on('pointermove',p=>{
            if(!p.isDown) return;
            if(p.event.touches?.length>=2){
                const[t1,t2]=p.event.touches;
                const dist=Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);
                this.coinStack.setScale(Phaser.Math.Clamp(this.initScale*(dist/this.initDist),0.3,10));
            }else if(this.isDragging){
                const dx=p.x-this.prevX, dy=p.y-this.prevY;
                this.coinStack.modelRotation.y += dx*this.rotSpeed;
                this.coinStack.modelRotation.x += dy*this.rotSpeed;
                [this.prevX,this.prevY]=[p.x,p.y];
            }
        });

        this.input.on('pointerup',()=>this.isDragging=this.isScaling=false);
        
        this.input.on('wheel',(_,__,___,dy)=>{
            this.coinStack.setScale(Phaser.Math.Clamp(this.coinStack.scaleX+dy*-this.scaleFactor,0.3,10));
        });

        this.scale.on('resize',s=>{
            this.cameras.main.setSize(s.width,s.height);
            this.coinStack.setPosition(s.width/2,s.height/2);
        });

        if(this.sys.game.device.input.touch) this.input.addTouchLock();
    }
}

const config = {
    type: Phaser.WEBGL,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game',
    scene: MainScene,
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    input: { activePointers:3, touch:{capture:true} },
    fps: { target:60, smoothStep:true },
    render: { antialiasGL:false }
};

new Phaser.Game(config);
window.addEventListener('resize',()=>game.scale.resize(window.innerWidth,window.innerHeight));
document.addEventListener('contextmenu',e=>e.preventDefault());
</script>
</body>
</html>