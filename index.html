<!DOCTYPE html>
<html>
<head>
    <meta name="telegram:verify" content="VERIFICATION_CODE_OT_BOTFATHER">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">	
    <link rel="manifest" href="https://ikelbik.github.io/tgtest/app-manifest.json">
    <link rel="icon" type="image/png" href="https://ikelbik.github.io/tgtest/favicon.png">    
    <meta charset="UTF-8">
    <meta name="theme-color" content="#000022">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; touch-action: none }
        body { background: #000022 }
        html, body, #game-container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –∑–∞–≥–ª—É—à–∫–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ */
        #orientation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,34,0.95);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #orientation-overlay .message {
            color: white;
            font-size: 24px;
            text-align: center;
            padding: 20px;
            max-width: 80%;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #orientation-overlay .icon {
            font-size: 48px;
            margin-bottom: 20px;
            animation: rotate 2s infinite linear;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(90deg); }
        }
    </style>
</head>
<body>
    <div id="game"></div>
    <!-- –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ—Ä—Ç—Ä–µ—Ç–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ -->
    <div id="orientation-overlay">
        <div class="icon">üîÑ</div>
        <div class="message">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</div>
    </div>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        const tg = window.Telegram?.WebApp;
        const orientationOverlay = document.getElementById('orientation-overlay');
        let game = null; // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É
        
        if (tg) {
            <!-- tg.ready(); -->
            tg.expand();
        }

        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        function checkOrientation() {
		if (tg){
            if (window.innerHeight < window.innerWidth) {
                orientationOverlay.style.display = 'flex';
                if (game && game.loop) {
                    game.loop.sleep();
                }
            } else {
                orientationOverlay.style.display = 'none';
                if (game && game.loop) {
                    game.loop.wake();
                }
            }
		}
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
		if (tg){
			checkOrientation();

			// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∏ —Ä–∞–∑–º–µ—Ä–∞
			window.addEventListener('resize', checkOrientation);
			window.addEventListener('orientationchange', checkOrientation);
		}
        let coins;
        let pile;
        
        function normalPDF(x, mu, sigma) {
            const coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
            const exponent = -((x - mu) ** 2) / (2 * sigma ** 2);
            return coefficient * Math.exp(exponent);
        }
        
        class mCoin extends Phaser.GameObjects.Sprite {
            constructor(scene, x, y, texture) {
                super(scene, x, y, texture);
                scene.add.existing(this);
                this.setAngle(Phaser.Math.Between(-7, 7));
            }
        }
        
        class Coin extends Phaser.GameObjects.Mesh {
            constructor(scene, x, y) {
                super(scene, x, y, 'texture');
                scene.add.existing(this);
        
                this.isJumping = false;
                this.isHolding = false;
                this.del_flag = true;
                this.floor_f = false;
                this.velocityY = 0;
                this.velocityX = 0;
                this.velocityZ = 1;
                this.currentSpin = 0;
                this.curentScale = 2.5;
                this.holdStartTime = 0;
                this.px_0 = 0;
                this.py_0 = 0;
                this.rot_amp = Phaser.Math.FloatBetween(0.05, 0.15);
                this.rot_f = Phaser.Math.FloatBetween(0.07, 0.1);
                this.setTint(0xFFFFFF);
                this.setAlpha(1);
                this.y_o = 0;
                this.s_y_o = 0;				
                this.cshdw = scene.add.mesh(0, 0, 'cshdw');	
                this.d_x = 0;		
                this.yoffset = 0;	
                this.ZforSpin = 0;
            }

            adjustBrightness(factor) {
                const value = Math.floor(255 * factor);
                const tint = Phaser.Display.Color.GetColor(value, value, value);
                this.setTint(tint);
            }		
        }

class LoadScene extends Phaser.Scene {
    constructor() {
        super({ key: 'LoadScene' });
        this.loadProgress = 0;
        this.isLoading = true;
        this.layersLoaded = {};
        this.animationStarted = false;
        this.layers = [];
        this.baseScreenLoaded = false;
        this.animationLoop = null;
        this.loadscreen0Layer = null; // –û—Ç–¥–µ–ª—å–Ω–æ —Ö—Ä–∞–Ω–∏–º —Å–ª–æ–π loadscreen0
    }

    init() {
        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π —Ñ–æ–Ω —Å—Ä–∞–∑—É, –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
        this.cameras.main.setBackgroundColor('#000022');
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ –Ω–∞—á–∞–ª–∞ preload
        this.load.on('progress', (value) => {
            this.loadProgress = value;
            this.updateProgressBar();
        });
        
        this.load.on('filecomplete', (key) => {
            console.log('Loaded:', key); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
            
            // –ö–∞–∫ —Ç–æ–ª—å–∫–æ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è –æ—Å–Ω–æ–≤–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë
            if (key === 'loadscreen' && !this.bg) {
                this.baseScreenLoaded = true;
                this.showLoadScreen();
            }
            
            // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É —Å–ª–æ–µ–≤
            if (key.startsWith('loadscreen') && key !== 'loadscreen') {
                this.layersLoaded[key] = true;
                console.log('Layer loaded:', key); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
                
                if (this.baseScreenLoaded) {
                    this.addLayer(key);
                    this.checkAllLayersLoaded();
                }
            }
        });
        
        this.load.on('complete', () => {
            console.log('All loading complete'); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
            this.isLoading = false;
            
            // –ï—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è –µ—â–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–æ–∏
            if (!this.animationStarted) {
                this.checkAllLayersLoaded();
            }
        });
    }

    preload() {
        this.load.setBaseURL('https://ikelbik.github.io/tgtest');
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –í–°–ï –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ä–∞–∑—É –≤ preload
        this.load.image('loadscreen', 'assets/loadscreen01.jpg');
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ª–æ–∏ loadscreen0-5 —Å—Ä–∞–∑—É
        for (let i = 0; i <= 5; i++) {
            this.load.image(`loadscreen${i}`, `assets/ld${i}.png`);
        }
        
        // –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ—Å–Ω–æ–≤–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã
        this.load.image('bg', 'assets/bg00.jpg');
        this.load.image('bg01', 'assets/bg01.png');	
        this.load.image('bg02', 'assets/bg02.png');				
        this.load.obj('coin', 'assets/ggcoin.obj');
        this.load.image('menubutton_1', 'assets/mbtn1.png');
        this.load.image('menubutton_2', 'assets/mbtn2.png');	
        this.load.image('menubutton_3', 'assets/mbtn3.png');				
        this.load.image('texture', 'assets/coin_txt_n.png');
        this.load.image('coin_t0', 'assets/coin_c00.png');
        this.load.image('coin_t1', 'assets/coin_c01.png');
        this.load.image('coin_t2', 'assets/coin_c02.png');
        this.load.image('coin_t3', 'assets/coin_c03.png');				
        this.load.image('cshdw', 'assets/shd_txt.png');
        this.load.audio('coinDrop', 'assets/drop.mp3');
        this.load.audio('coinUp', 'assets/up.mp3');
        this.load.audio('magic', 'assets/rise.wav');  
        this.load.atlas('flares', 'assets/flares.png', 'assets/flares.json');
    }

    showLoadScreen() {

		// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∑–∞—Å—Ç–∞–≤–∫—É –∫–∞–∫ —Ç–æ–ª—å–∫–æ –æ–Ω–∞ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å
        this.bg = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'loadscreen');
        
		//this.bg = this.add.image(this.cameras.main.centerX, 0, 'loadscreen').setOrigin(0.5, 0);
		const scaleX = this.cameras.main.width / this.bg.width;
		const scaleY = this.cameras.main.height / this.bg.height;
		
        const scale = Math.max(scaleX, scaleY);
		
		const ratio = (this.cameras.main.width/this.cameras.main.height) / (this.scale.displaySize.width/this.scale.displaySize.height)
		
		
    console.log('Camera size:', this.cameras.main.width, 'x', this.cameras.main.height);
    console.log('Scale size:', this.scale.width, 'x', this.scale.height);
    console.log('Display size:', this.scale.displaySize.width, 'x', this.scale.displaySize.height);
	   console.log('Resolution:',ratio);
		
		
		//const scale = this.scale.displaySize.height / this.bg.height; 
		
	    this.bg.setScale(scale);
		//console.log(his.scale.displaySize.width, ' ', this.bg.height*scale)
		//this.bg.y += (this.cameras.main.height - this.bg.displayHeight)/1;

        // –°–æ–∑–¥–∞–µ–º UI —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–≤–µ—Ä—Ö –∑–∞—Å—Ç–∞–≤–∫–∏
        this.createProgressBarUI();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–ª–æ–∏ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        this.checkAllLayersLoaded();
    }

    addLayer(layerKey) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç —Å–ª–æ–π
        if (this.layers.find(layer => layer.texture.key === layerKey) || 
            (this.loadscreen0Layer && this.loadscreen0Layer.texture.key === layerKey)) {
            return;
        }
        
        //console.log('Adding layer:', layerKey); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π —Å–ª–æ–π –ø–æ–≤–µ—Ä—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å alpha = 0
        const layer = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, layerKey);
        //const layer = this.add.image(this.cameras.main.centerX, 0, layerKey).setOrigin(0.5, 0);
        const scaleX = this.cameras.main.width / layer.width;
        const scaleY = this.cameras.main.height / layer.height;
        const scale = Math.max(scaleX, scaleY);
        layer.setScale(scale);
        layer.setAlpha(0); // –ù–∞—á–∞–ª—å–Ω–æ –Ω–µ–≤–∏–¥–∏–º—ã–π
        
        // –†–∞–∑–¥–µ–ª—è–µ–º loadscreen0 –æ—Ç –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–æ–µ–≤
        if (layerKey === 'loadscreen0') {
            this.loadscreen0Layer = layer;
        } else {
            this.layers.push(layer);
        }
        
        // –†–∞—Å–ø–æ–ª–∞–≥–∞–µ–º UI —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–≤–µ—Ä—Ö –≤—Å–µ—Ö —Å–ª–æ–µ–≤
        if (this.progressBg) this.progressBg.setDepth(100);
        if (this.progressBorder) this.progressBorder.setDepth(100);
        if (this.progressBar) this.progressBar.setDepth(100);
        if (this.percentText) this.percentText.setDepth(100);
        if (this.loadingText) this.loadingText.setDepth(100);
    }

    checkAllLayersLoaded() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≥—Ä—É–∂–µ–Ω—ã –ª–∏ –≤—Å–µ —Å–ª–æ–∏ (–≤–∫–ª—é—á–∞—è loadscreen0)
        const requiredLayers = ['loadscreen0', 'loadscreen1', 'loadscreen2', 'loadscreen3', 'loadscreen4', 'loadscreen5'];
        const allLoaded = requiredLayers.every(layer => this.layersLoaded[layer]);
        
        if (allLoaded && this.baseScreenLoaded && !this.animationStarted) {
            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Å–ª–æ–∏, –∫–æ—Ç–æ—Ä—ã–µ –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã
            requiredLayers.forEach(layerKey => {
                this.addLayer(layerKey);
            });
            
            this.startLayerAnimation();
        }
    }

    startLayerAnimation() {
        this.animationStarted = true;
        
        if (this.layers.length === 0 && !this.loadscreen0Layer) {
            console.log('No layers to animate!');
            return;
        }
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω—É—é —Å–ª—É—á–∞–π–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è loadscreen0
        this.startLoadscreen0Animation();
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞—Ü–∏–∫–ª–µ–Ω–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è —Å–ª–æ–µ–≤ 1-5
        this.runAnimationCycle();
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è, –Ω–æ –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è
        this.time.delayedCall(800, () => {
            this.showPlayButton();
        });
    }

    startLoadscreen0Animation() {
        if (!this.loadscreen0Layer) return;
        
        const animateLoadscreen0 = () => {
            if (!this.animationStarted) return; // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏
            
            // –°–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ alpha –æ—Ç 0.1 –¥–æ 0.8
            const randomAlpha = Math.random() * 0.6 + 0.2;
            // –°–ª—É—á–∞–π–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç 50 –¥–æ 300ms
            const randomDuration = Math.random() * 0 + 100;
            
            this.tweens.add({
                targets: this.loadscreen0Layer,
                alpha: randomAlpha,
                duration: randomDuration,
                ease: 'Power2',
                onComplete: () => {
                    // –°–ª—É—á–∞–π–Ω–∞—è –ø–∞—É–∑–∞ –æ—Ç 30 –¥–æ 150ms –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π
                    const randomDelay = Math.random() * 120 + 30;
                    this.time.delayedCall(randomDelay, animateLoadscreen0);
                }
            });
        };
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—É—é –∞–Ω–∏–º–∞—Ü–∏—é loadscreen0
        animateLoadscreen0();
    }

    runAnimationCycle() {
        if (this.layers.length === 0) return;
        
        // –°–æ–∑–¥–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –ø–æ–∫–∞–∑–∞ —Å–ª–æ–µ–≤ 1-5
        const shuffleArray = (array) => {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        };
        
        let currentLayerIndex = 0;
        let shuffledLayers = shuffleArray(this.layers);
        
        const animateNextLayer = () => {
            if (!this.animationStarted) return; // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏
            
            if (currentLayerIndex >= shuffledLayers.length) {
                // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Å–ª–æ–∏ –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
                this.layers.forEach(layer => layer.setAlpha(0));
                currentLayerIndex = 0;
                shuffledLayers = shuffleArray(this.layers);
            }
            
            const layer = shuffledLayers[currentLayerIndex];
            
            this.tweens.add({
                targets: layer,
                alpha: 1,
                duration: 80,
                ease: 'Power2',
                onComplete: () => {
                    // –ß–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è —Å–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π
                    this.time.delayedCall(30, () => {
                        //layer.setAlpha(0);
						this.tweens.add({
							targets: layer,
							alpha: 0,
							duration: 80,
							ease: 'Power2'
						});
						
						currentLayerIndex++;
                        
                        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ü–∏–∫–ª, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è –µ—â–µ –∞–∫—Ç–∏–≤–Ω–∞
                        if (this.animationStarted) {
                            animateNextLayer();
                        }
                    });
                }
            });
        };
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—É—é –∞–Ω–∏–º–∞—Ü–∏—é
        animateNextLayer();
    }

    createProgressBarUI() {
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        this.createProgressBar();
        
        // –¢–µ–∫—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏
        this.loadingText = this.add.text(this.cameras.main.centerX, this.cameras.main.height - 200, 
            '–ó–∞–≥—Ä—É–∑–∫–∞...', {
            font: '28px Arial',
            fill: '#ffffff',
            align: 'center'
        }).setOrigin(0.5).setDepth(100);
    }

    create() {
        // –ï—Å–ª–∏ –∑–∞—Å—Ç–∞–≤–∫–∞ –µ—â–µ –Ω–µ –ø–æ–∫–∞–∑–∞–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å), —Å–æ–∑–¥–∞–µ–º fallback
        if (!this.bg) {
            this.time.delayedCall(100, () => {
                if (this.textures.exists('loadscreen')) {
                    this.baseScreenLoaded = true;
                    this.showLoadScreen();
                } else {
                    // Fallback - –ø—Ä–æ—Å—Ç–æ–π —Ñ–æ–Ω
                    this.bg = this.add.rectangle(this.cameras.main.centerX, this.cameras.main.centerY, 
                                               this.cameras.main.width, this.cameras.main.height, 0x000044);
                    this.createProgressBarUI();
                }
            });
        }
    }

    createProgressBar() {
        const barWidth = 300;
        const barHeight = 20;
        const x = this.cameras.main.centerX - barWidth / 2;
        const y = this.cameras.main.height - 250;

        // –§–æ–Ω –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        this.progressBg = this.add.graphics();
        this.progressBg.fillStyle(0x222222, 0.8);
        this.progressBg.fillRoundedRect(x, y, barWidth, barHeight, 10);
        this.progressBg.setDepth(100);
        
        // –†–∞–º–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        this.progressBorder = this.add.graphics();
        this.progressBorder.lineStyle(2, 0xffffff, 0.8);
        this.progressBorder.strokeRoundedRect(x, y, barWidth, barHeight, 10);
        this.progressBorder.setDepth(100);

        // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        this.progressBar = this.add.graphics();
        this.progressBar.setDepth(100);
        
        // –¢–µ–∫—Å—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞
        this.percentText = this.add.text(this.cameras.main.centerX, y + barHeight / 2, '0%', {
            font: '16px Arial',
            fill: '#ffffff'
        }).setOrigin(0.5).setDepth(100);
    }

    updateProgressBar() {
        if (!this.progressBar) return; // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ progressBar
        
        const barWidth = 300;
        const barHeight = 20;
        const x = this.cameras.main.centerX - barWidth / 2;
        const y = this.cameras.main.height - 250;
        
        this.progressBar.clear();
        
        // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç —Å–∏–Ω–µ–≥–æ –∫ –∑–µ–ª–µ–Ω–æ–º—É
        const progress = this.loadProgress;
        const fillWidth = barWidth * progress;
        
        if (fillWidth > 0) {
            // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
            const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                { r: 100, g: 150, b: 255 }, // –°–∏–Ω–∏–π
                { r: 100, g: 255, b: 100 }, // –ó–µ–ª–µ–Ω—ã–π
                100,
                Math.floor(progress * 100)
            );
            
            this.progressBar.fillStyle(Phaser.Display.Color.GetColor(color.r, color.g, color.b));
            this.progressBar.fillRoundedRect(x, y, fillWidth, barHeight, 10);
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞
        if (this.percentText) {
            this.percentText.setText(Math.floor(progress * 100) + '%');
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏
        if (this.loadingText && !this.animationStarted) {
            if (progress < 1) {
                this.loadingText.setText('–ó–∞–≥—Ä—É–∑–∫–∞... ' + Math.floor(progress * 100) + '%');
            } else {
                this.loadingText.setText('–ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
            }
        }
    }

    showPlayButton() {
        // –°–∫—Ä—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∑–∞–≥—Ä—É–∑–∫–∏
        if (this.progressBg) this.progressBg.setVisible(false);
        if (this.progressBorder) this.progressBorder.setVisible(false);
        if (this.progressBar) this.progressBar.setVisible(false);
        if (this.percentText) this.percentText.setVisible(false);
        if (this.loadingText) this.loadingText.setVisible(false);
        
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ –ø–æ–∫–∞–∑–µ –∫–Ω–æ–ø–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        // this.animationStarted = false;
        
        if (tg) {
            tg.MainButton.setText('–ò–≥—Ä–∞—Ç—å');
            tg.MainButton.show();
            tg.MainButton.onClick(() => {
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º
                this.animationStarted = false;
                this.scene.start('MainScene');
            });
        } 
        //this.scene.start('MainScene');
    }
}
        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
                this.score = 0;
                this.gravity = 0.5;
                this.bounceDamping = 0.8;
                this.minHoldTime = 0;
                this.maxHoldTime = 800;
                this.maxJumpForceX = 25;
                this.maxJumpForceY = 60;
                this.maxJumpForceZ = 60;				
                this.maxDx = 100;
                this.maxDy = 100;
                this.baseYOffset = 200;
                this.soundVolume = 0.6;
                this.bg01_height = 405;
                this.bg02_height = 491;
                this.mcoin_width = 53;
                this.mcoin_height = 41;
				this.mbtn1_height = 219;
                this.pile_high = 0;
                this.resolution_coeff = 1;
                this.max_i = 0;
                this.e_flag = true;
				this.canShine = [true,true,true];
            }
        
            preload() {
                // –í—Å–µ —Ä–µ—Å—É—Ä—Å—ã —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ LoadScene
                // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è MainScene
            }

            create() {
                if (tg) {
                    tg.MainButton.hide();
                    tg.onEvent('backButtonClicked', () => {
                        tg.close();
                    });
                }
              
                coins = this.add.group();
                pile = this.add.group();

                this.bounceSound = this.sound.add('coinDrop', { volume: this.soundVolume });
                this.upSound = this.sound.add('coinUp', { volume: this.soundVolume });
                this.mSound = this.sound.add('magic', { volume: this.soundVolume - 0.2 });

                this.bg = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'bg');

                this.plane01 = this.add.plane(this.cameras.main.centerX, this.cameras.main.height, 'bg01').panZ(0);	
                this.plane02 = this.add.plane(this.cameras.main.centerX, this.cameras.main.height, 'bg02').panZ(0);				
                
                this.plane01.setDepth(100);
                this.plane01.z = 1;
                this.plane02.setDepth(200);
                this.plane02.z = 0.5;				

                const scaleX = this.cameras.main.width / this.bg.width;
                const scaleY = this.cameras.main.height / this.bg.height;
                this.scale = Math.max(scaleX, scaleY);
                
                this.bg.setScale(this.scale).setScrollFactor(0);
                this.plane01.setScale(this.scale);
                this.plane01.y = (this.bg.height - this.bg01_height) * this.scale;
                this.plane02.setScale(this.scale);
                this.plane02.y = (this.bg.height - 2 * this.bg01_height - this.bg02_height) * this.scale;	
										
				const  d_buttons_x = this.cameras.main.width / 6;
				// –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –º–µ–Ω—é 1
				const mbtn1_y = (this.bg.height - this.mbtn1_height) * this.scale;
                this.menuButton1 = this.add.sprite(d_buttons_x, mbtn1_y, 'menubutton_1')
                    .setInteractive()
                    .setDepth(1000);                
				this.menuButton1.setScale(1*this.scale);
				
				// –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –¥–ª—è menuButton1
                this.pulseTween = this.tweens.add({
                    targets: this.menuButton1,
                    scaleX: 1.1 * this.scale,
                    scaleY: 1.1 * this.scale,
                    duration: 800,
                    ease: 'Sine.easeInOut',
                    yoyo: true,
                    repeat: -1
                });
				
				// –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –º–µ–Ω—é 2
				const mbtn2_y = (this.bg.height - this.mbtn1_height) * this.scale;
                this.menuButton2 = this.add.sprite(3*d_buttons_x, mbtn2_y, 'menubutton_2')
                    .setInteractive()
                    .setDepth(1000);
                this.menuButton2.setScale(1*this.scale);
				
				// –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –º–µ–Ω—é 3
				const mbtn3_y = (this.bg.height - this.mbtn1_height) * this.scale;
                this.menuButton3 = this.add.sprite(5*d_buttons_x, mbtn2_y, 'menubutton_3')
                    .setInteractive()
                    .setDepth(1000);
                this.menuButton3.setScale(1*this.scale);				

				// –≠—Ñ—Ñ–µ–∫—Ç –±–ª–µ—Å–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏ 1 (–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–ø—Ä–∞–π—Ç)
                this.shine1 = this.add.sprite(this.menuButton1.x, this.menuButton1.y, 'menubutton_1')
                    .setScale(1*this.scale)
                    .setAlpha(0)
                    .setDepth(1001)
                    .setBlendMode(Phaser.BlendModes.ADD);
					
				// –≠—Ñ—Ñ–µ–∫—Ç –±–ª–µ—Å–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏ 2 (–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–ø—Ä–∞–π—Ç)
                this.shine2 = this.add.sprite(this.menuButton2.x, this.menuButton2.y, 'menubutton_2')
                    .setScale(1*this.scale)
                    .setAlpha(0)
                    .setDepth(1001)
                    .setBlendMode(Phaser.BlendModes.ADD);

				// –≠—Ñ—Ñ–µ–∫—Ç –±–ª–µ—Å–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏ 3 (–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–ø—Ä–∞–π—Ç)
                this.shine3 = this.add.sprite(this.menuButton3.x, this.menuButton3.y, 'menubutton_3')
                    .setScale(1*this.scale)
                    .setAlpha(0)
                    .setDepth(1001)
                    .setBlendMode(Phaser.BlendModes.ADD);	

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—É–ª—å—Å–∞—Ü–∏–∏ –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏
                this.menuButton2.on('pointerover', () => {
                    this.pulseTween.stop();
                    this.menuButton1.setScale(1 * this.scale);
                });

                this.menuButton3.on('pointerover', () => {
                    this.pulseTween.stop();
                    this.menuButton1.setScale(1 * this.scale);
                });					

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                this.lastGamma = 0;
				
				// –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                this.orientationHandler = (event) => {
                    if (event.gamma !== null) {
                        this.handleDeviceOrientation(event.gamma);
                    }
                };
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫—É –º–µ–Ω—é
                this.menuButton1.on('pointerdown', () => {
                    console.log('Menu 1 button pressed');
                    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –º–µ–Ω—é
                });
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫—É –º–µ–Ω—é
                this.menuButton2.on('pointerdown', () => {
                    console.log('Menu 2 button pressed');
                    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –º–µ–Ω—é
                });
				
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫—É –º–µ–Ω—é
                this.menuButton3.on('pointerdown', () => {
					window.location.href = "https://ikelbik.github.io/tgtest/wallet.html";
                });
				
				
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (event) => {
                        if (event.gamma !== null) {
                            this.handleOrientation(event.gamma);
                        }
                    });
                } else {
                    console.log("Device orientation not supported");
                }				
                    
				// –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–∏ —Å—Ü–µ–Ω—ã
                this.events.on('destroy', () => {
                    if (window.DeviceOrientationEvent) {
                        window.removeEventListener('deviceorientation', this.orientationHandler);
                    }
                });					
					
                this.stnLevel = (this.bg.height - 2 * this.bg01_height) * this.scale;
                this.baseYOffset = 450 * this.scale;
                this.target_y = (this.bg.height - 2 * this.bg01_height - 2 * this.bg02_height + 300) * this.scale;
                this.target_x = this.cameras.main.centerX;
                this.pileX = this.target_x;
                this.pileY = (this.bg.height - 2 * this.bg01_height - 0.8 * this.bg02_height) * this.scale;
                this.perspective = 112 * this.scale;
                this.zfactor = 500 * this.scale;
                this.coin_h = 30 * this.scale;
                this.target_r = 240;
                
                this.b1 = (this.zfactor / this.perspective + 1) * 0.57;
                this.b2 = (this.zfactor / this.perspective + 1) * 0.85;
                this.b3 = (this.zfactor / this.perspective + 1) * 1;				
                
                this.scoreText = this.add.text(20, 30, "–ú–æ–Ω–µ—Ç : 0", {
                    font: '28px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setScrollFactor(0);
                
                this.is_n = Phaser.Math.Between(1, 5);
                this.createMultiCoin(this.is_n);
                this.get_up_coin();
                this.InitPile();
				
            }
			        
            createMultiCoin(n) {
                this.mSound.play();
                const randomX = Phaser.Math.Between(-this.cameras.main.width / 3.5, this.cameras.main.width / 3.5);
                const x = this.cameras.main.centerX + randomX;
                this.triggerLightning(x, this.cameras.main.centerY + this.baseYOffset);
                for (let i = 1; i <= n; i++) {	
                    const y = (i - 1) * this.coin_h;
                    this.createNewCoin(x, y);
                }
            }
            
            sc(x, y, h, w) {
                return 1 - 0.3 * (Math.pow(x / w, 4) + Math.pow(y / h, 4));
            }

            tnt(x, y, h, w) {
                const r = 255 - 220 * (Math.exp(2 * (y - h) / h)) + 20 * Math.pow(2 * Math.abs(x - w / 300) / w, 3);
                return Math.max(20, Math.min(255, r));
            }
            
            UpPile() {
                this.pile_high += 0.01;
                if (this.pile_high > 1) this.pile_high = 1;
            }
            
            SetPile() {
                if (this.pile_high < 1) {
                    for (const mcoin of pile.getChildren()) {
                        const c_y = mcoin.y - (0.01 * 220) * this.scale;
                        mcoin.y = c_y;
                        const rd = Math.sqrt(Math.pow((this.target_x - mcoin.x), 2) + Math.pow((this.target_y - c_y), 2));
                        if (rd < (this.target_r + this.mcoin_width - 80 * (1 - this.pile_high)) * this.scale) {
                            mcoin.setVisible(true);
                        }
                    }
                }
            }
            
            InitPile() {
                const h = 400 * this.scale;
                const w = 400 * this.scale;
                let coin_dx = -w;
                let hh = 0;
                let dpt = 0.4;
                
                for (let i = 0; i <= 2000; i++) {
                    const ss = this.scale * this.sc(coin_dx, hh, h, w);
                    if (i >= 250) {
                        const bx = hh * normalPDF(coin_dx / w, 0, 0.6);					
                        const x = Phaser.Math.Between(coin_dx - this.mcoin_width / 2 * ss, coin_dx + this.mcoin_width / 2 * ss);
                        const coin_dy = Phaser.Math.Between(-this.mcoin_height / 2 * ss, this.mcoin_height / 2 * ss);
                        const c_x = this.pileX + x;
                        const c_y = this.pileY - bx - coin_dy;
                        const rd = Math.sqrt(Math.pow((this.target_x - c_x), 2) + Math.pow((this.target_y - c_y), 2));
                        
                        if (rd < (this.target_r + this.mcoin_width) * this.scale) {		
                            const c_im_p = Phaser.Math.Between(0, 3);
                            const c_im_t = 'coin_t' + c_im_p;
                            const mcoin = new mCoin(this, this.pileX + x, this.pileY - bx - coin_dy + 0.5 * this.bg02_height * this.scale, c_im_t);
                            mcoin.setVisible(false);
                            mcoin.setDepth(dpt);
                            let sc_xy = 1.3 - Math.abs(1.4 * coin_dx / w) / 2 - Math.abs(0.7 * hh / h) / 1.3;
                            if (sc_xy < 0.1) sc_xy = 0.1;
                            mcoin.setScale(ss, ss * sc_xy); 
                            const tint0 = this.tnt(coin_dx, hh - 100 * this.scale, h, w);
                            const tint = Phaser.Display.Color.GetColor(
                                tint0 - Phaser.Math.Between(10, 20), 
                                tint0 - Phaser.Math.Between(0, 10), 
                                tint0
                            );
                            mcoin.setTint(tint);
                            pile.add(mcoin);
                        }
                    }
                    coin_dx += ss * this.mcoin_width / 2;
                    if (coin_dx > w) {
                        coin_dx = -w;
                        hh += this.mcoin_height / 3 * ss;
                        dpt = 20 + Phaser.Math.FloatBetween(-15, 15);
                    }
                }
            }
                
            createNewCoin(x, y) {
                const randomX = Phaser.Math.Between(-50 * this.scale, 50 * this.scale);
                const randomZOffset = Phaser.Math.FloatBetween(-0.02, 0.02);
                this.currentYOffset = this.baseYOffset - 150 * randomZOffset;
                
                const startY = this.cameras.main.centerY - 300;
                const targetY = this.cameras.main.centerY + this.currentYOffset - y;				
                const targetX = x + randomX;
                
                const coin = new Coin(this, targetX, startY);		
                coin.addVerticesFromObj('coin', 0.1).panZ(7).modelRotation.x += 0.6;
                
                coin.yoffset = y;
                coin.z += 0.9 + randomZOffset;
                coin.setScale(coin.curentScale);
                coin.setDepth(200);
                
                coin.cshdw.addVerticesFromObj('coin', 0.1).panZ(7).modelRotation.x += 0.6;
                coin.cshdw.setPosition(targetX - 10 * this.scale, targetY + 50 * this.scale);
                coin.cshdw.setDepth(150);
                coin.cshdw.setScale(1.1 * coin.curentScale);
                coin.cshdw.setAlpha(0.3);
                if (coin.yoffset != 0) coin.cshdw.setVisible(false); 
                
                const circle = new Phaser.Geom.Circle(0, 0, 300);
                coin.setInteractive({ hitArea: circle, hitAreaCallback: Phaser.Geom.Circle.Contains });
                coin.disableInteractive();
                
                this.tweens.add({
                    targets: coin,
                    alpha: { from: 0, to: 1 },
                    y: { from: startY, to: targetY },
                    duration: 300,
                    ease: 'Cubic.easeOut'
                });
                
                this.tweens.add({
                    targets: coin.cshdw,
                    alpha: { from: 0, to: 0.3 },
                    duration: 300
                });
                
                coin.on('pointerdown', p => {
                    this.UpPile();
                    this.SetPile();
                    if (!coin.isJumping) {
                        coin.isHolding = true;
                        coin.holdStartTime = this.time.now;
                        coin.px_0 = p.x;
                        coin.py_0 = p.y;
                    }
                });

                this.input.on('pointerup', p => {
                    if (coin.isHolding && !coin.isJumping) {
                        this.upSound.play();
                        const holdDuration = Phaser.Math.Clamp(this.time.now - coin.holdStartTime, 0, this.maxHoldTime);
                        const holdX = Phaser.Math.Clamp(coin.px_0 - p.x, -this.maxDx, this.maxDx) / this.maxDx;
                        const holdY = Phaser.Math.Clamp(coin.py_0 - p.y, 0, this.maxDy) / this.maxDy;
                        
                        if (holdDuration >= this.minHoldTime && holdY > 0) {
                            coin.velocityY = -0.9 * this.resolution_coeff * Phaser.Math.Clamp(17 * this.maxJumpForceY * holdY / holdDuration, 4, 23);
                            coin.velocityZ = 0.9 * Phaser.Math.Clamp(0.07 * this.maxJumpForceZ * holdY / holdDuration, 0.08, 0.15);
                            coin.velocityX = -this.maxJumpForceX * holdX / 3;
                            coin.ZforSpin = coin.velocityZ;
                            coin.isJumping = true;
                            this.get_up_coin();
                            coin.modelRotation.y -= coin.velocityX / 17;
                            coin.cshdw.setVisible(true); 
                            coin.isHolding = false;
                            coin.currentSpin = (coin.velocityZ <= 0.9 * 0.08 && coin.velocityY > -7) ? -0.05 : 0.2;
                        }
                    }
                });
                
                coins.add(coin);
            }

            get_c_len() {
                let i = 0;
                coins.getChildren().forEach(coin => {
                    if (!coin.isJumping) i += 1;
                });
                return i;
            }
            
            get_up_coin() {
                let max = -1;
                this.max_i = 0;
                coins.getChildren().forEach((coin, index) => {
                    if (!coin.isJumping && coin.yoffset > max) {
                        max = coin.yoffset;
                        this.max_i = index;
                    }
                });
                
                if (coins.getChildren()[this.max_i]) {
                    coins.getChildren()[this.max_i].setInteractive();
                }
            }
			
			 // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
            handleOrientation(gamma) {
				if (this.lastGamma === undefined) {
					this.lastGamma = gamma;
					return;
				}
				
				const ang = [-5, 0, +5];
				for (let i = 0; i < 3; i++) {

				if (
					(this.lastGamma < ang[i] && gamma >= ang[i]) ||  // –°–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
					(this.lastGamma > ang[i] && gamma <= ang[i])     // –°–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
				) {
					if (this.canShine[i]) {
						this.triggerShineEffect(i);
						this.canShine[i] = false;
						this.time.delayedCall(500, () => { 
						this.canShine[i] = true; 
						});
					}
				}
				}
				this.lastGamma = gamma;
            }

            // –ê–∫—Ç–∏–≤–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –±–ª–µ—Å–∫–∞
            triggerShineEffect(m) {
				if (m==2) {
				this.tweens.add({
                    targets: this.shine1,
                    alpha: { from: 0.6, to: 0 },
                    //scale: { from: 2.0, to: 2 },
                    duration: 200,
                    ease: 'Cubic.easeOut',
                    onStart: () => {
                        this.shine1.setPosition(this.menuButton1.x, this.menuButton1.y);
                        this.shine1.setAlpha(1);
                    }
                });
				}
				
				if (m==1) {
				this.tweens.add({
                    targets: this.shine2,
                    alpha: { from: 0.6, to: 0 },
                    //scale: { from: 2.0, to: 2 },
                    duration: 200,
                    ease: 'Cubic.easeOut',
                    onStart: () => {
                        this.shine2.setPosition(this.menuButton2.x, this.menuButton2.y);
                        this.shine2.setAlpha(1);
                    }
                });
				}
				
				if (m==0) {
				this.tweens.add({
                    targets: this.shine3,
                    alpha: { from: 0.6, to: 0 },
                    //scale: { from: 2.0, to: 2 },
                    duration: 200,
                    ease: 'Cubic.easeOut',
                    onStart: () => {
                        this.shine3.setPosition(this.menuButton3.x, this.menuButton3.y);
                        this.shine3.setAlpha(1);
                    }
                });
				}				
				
            }
			
            update(time, delta) {
			
                const cl = this.get_c_len();
                const dt = 1.5 * delta / 16.66667;
                
                if (cl == 0 && this.e_flag) {
                    this.time.delayedCall(500, () => {
                        this.is_n = Phaser.Math.Between(1, 5);					
                        this.createMultiCoin(this.is_n);
                        this.get_up_coin();
                    });    
                    this.e_flag = false;		
                }
                                
                coins.getChildren().forEach(coin => {
                    if (!coin.isJumping) {
                        if (coin.rot_amp >= 0.01) {
                            coin.rot_amp *= 1 / (1 + coin.rot_f);
                            coin.modelRotation.x = 0.6 - coin.rot_amp * Math.sin(this.time.now * coin.rot_f);
                            coin.modelRotation.z = coin.rot_amp * Math.sin(this.time.now * coin.rot_f + Math.PI / 2);
                            coin.cshdw.setScale(1.1 * coin.curentScale * Math.cos(coin.modelRotation.z), 1.1 * coin.curentScale * Math.cos(coin.modelRotation.x));
                        }
                    } else {
                        if (cl > 0) this.e_flag = true;
                        
                        coin.velocityY += this.gravity * dt;
                        coin.z += coin.velocityZ * dt;
                        coin.y += coin.velocityY * dt;
                        
                        if (coin.cshdw) {
                            coin.cshdw.y -= -coin.s_y_o + this.perspective * (coin.z - 1) - coin.yoffset;
                            const dsh_y = Phaser.Math.Clamp(0.7 * (coin.cshdw.y - coin.y) / 15, 3.3, 100);
                            coin.cshdw.setAlpha(1 / dsh_y);
                        }
                        
                        coin.y -= -coin.y_o + this.perspective * (coin.z - 1);
                        coin.y_o = this.perspective * (coin.z - 1);		
                        coin.s_y_o = this.perspective * (coin.z - 1) - coin.yoffset;						
                        coin.curentScale = 2.5 / coin.z;
                        coin.setScale(coin.curentScale);
                        
                        if (coin.cshdw) {
                            coin.cshdw.setScale(2.8 / coin.z, 2.5 * Math.sin(coin.modelRotation.x) / coin.z);
                        }
                        
                        coin.x += coin.velocityX * dt;
                        if (coin.cshdw) {
                            coin.cshdw.x = coin.x - 5;	
                        }
                        
                        if (Math.abs(coin.modelRotation.x - Math.PI / 2) < 0.2 || Math.abs(coin.modelRotation.x - 3 * Math.PI / 2) < 0.2) {
                            coin.setTint(0xFFFFFF);
                            coin.setBlendMode(Phaser.BlendModes.ADD);
                            coin.setAlpha(1.5);						
                        } else {
                            coin.adjustBrightness(Math.pow(coin.curentScale / 2.5, 0.25));
                            coin.setBlendMode(Phaser.BlendModes.NORMAL);
                            coin.setAlpha(1);						
                        }
                        
                        coin.modelRotation.x += coin.currentSpin * (coin.ZforSpin / 0.1) * dt;
                        if (coin.modelRotation.x > 2 * Math.PI) {
                            coin.modelRotation.x -= 2 * Math.PI;
                        }
                        
                        coin.floor_f = false;
                        
                        if (coin.z <= this.b1) coin.d_x = 1;
                        if (coin.z > this.b1 && coin.z <= this.b2) coin.d_x = 2;
                        if (coin.z >= this.b2 && coin.z < this.b3 && coin.y < this.stnLevel - 85) {
                            coin.d_x = 3;
                            if (coin.del_flag) coin.cshdw.setVisible(true);
                        }			
                        if (coin.z >= this.b3) {
                            const rd = Math.sqrt(Math.pow((this.target_x - coin.x), 2) + Math.pow((this.target_y - coin.y), 2));
                            if (coin.d_x < 5) coin.d_x = 4;													
                            if (rd < this.target_r * this.scale) coin.d_x = 5;
                        }			
                        
                        if (coin.y >= this.cameras.main.centerY + this.currentYOffset - this.perspective * (coin.z - 1)) {
                            coin.floor_f = true;
                        }

                        if (coin.d_x == 4 && coin.del_flag) {
                            coin.z = this.b3;
                            coin.velocityZ = (coin.velocityZ < 0.04) ? -0.04 : -0.04;
                            if (coin.y < 100) coin.velocityZ = -0.004;
                            
                            if (Math.abs(coin.velocityY) > 1) {
                                this.bounceSound.play({
                                    volume: Phaser.Math.Clamp(Math.abs(coin.velocityY) / 25, 0.3, 1)
                                });
                            } 
                            if (coin.x > this.target_x + (this.target_r - 150) * this.scale) {
                                coin.velocityX = -Math.abs(coin.velocityY / 1);
                            }
                        }
                        
                        if (coin.d_x == 2) coin.cshdw.setVisible(false);
                        
                        if (coin.d_x == 2 && coin.y >= this.stnLevel - 30 && coin.del_flag) {
                            coin.setDepth(70);
                            this.time.delayedCall(300, () => {	
                                coin.destroy();		
                            });
                            coin.del_flag = false;				
                        }	

                        if (coin.d_x == 5) {
                            coin.cshdw.setVisible(false);							
                            if (coin.del_flag) {
                                coin.setDepth(45);
                                this.score += 1;
                                this.scoreText.setText(`–ú–æ–Ω–µ—Ç : ${this.score}`);								
                                this.time.delayedCall(1000, () => {	
                                    if (coin) coin.destroy();										
                                });
                                coin.del_flag = false;				
                            }
                        }			

                        if (coin.y > 3000 && coin) coin.destroy();
                        
                        if (coin.floor_f && coin.d_x != 2 && coin.del_flag) { 
                            this.score += 1;
                            coin.y = this.cameras.main.centerY + this.currentYOffset - this.perspective * (coin.z - 1);
                            coin.velocityY *= -this.bounceDamping;
                            coin.velocityZ = 0 + (coin.velocityZ - 0) / 1.8;
                            coin.velocityX = coin.velocityX / 3;
                            
                            if (Math.abs(coin.velocityY) > 1) {
                                this.bounceSound.play({
                                    volume: Phaser.Math.Clamp(Math.abs(coin.velocityY) / 25, 0.3, 1)
                                });
                            }

                            if (Math.abs(coin.velocityY) < 1) {
                                if (Math.abs(coin.modelRotation.x) - 0.6 < 0.2 || 
                                    Math.abs(coin.modelRotation.x) - (2 * Math.PI + 0.6) < 0.2) {
                                    coin.velocityY = 0;
                                    coin.velocityX = 0;
                                    coin.cshdw.setVisible(false);
                                    this.tweens.add({
                                        targets: [coin, coin.cshdw],
                                        alpha: 0,
                                        duration: 300,
                                        ease: 'Cubic.easeOut',
                                        onComplete: () => {
                                            if (coin.del_flag) {
                                                this.time.delayedCall(500, () => {	
                                                    coin.destroy();
                                                    coin.cshdw.destroy();		
                                                });	
                                                coin.del_flag = false;
                                            }
                                        }
                                    });
                                } else {
                                    coin.modelRotation.x -= 0.3;
                                }						
                            }
                        }						
                    }
                });
            }

            triggerLightning(x, y) {
                const points = [];
                const segments = 15;
                const maxDeviation = 170;
    
                points.push(new Phaser.Math.Vector2(x, 0));
    
                for (let i = 1; i < segments; i++) {
                    const progress = i / segments;
                    const yPos = y * progress;
                    const deviation = maxDeviation * Math.sin(progress * Math.PI);
                    const xDev = Phaser.Math.Between(-deviation, deviation);
                    points.push(new Phaser.Math.Vector2(x + xDev, yPos));
                }
    
                points.push(new Phaser.Math.Vector2(x, y));
                const lightningCurve = new Phaser.Curves.Spline(points);
    
                const lightning = this.add.particles(0, 0, 'flares', {
                    frame: { frames: ['white', 'yellow', 'blue'], cycle: true },
                    blendMode: 'ADD',
                    lifespan: { min: 100, max: 300 },
                    quantity: 3,
                    scale: { start: 1.9, end: 0 },
                    alpha: { start: 0.6, end: 0.0 },
                    advance: 0,
                    emitZone: {
                        type: 'edge',
                        source: lightningCurve,
                        quantity: 64,
                        stepRate: 0
                    }
                });
                lightning.setDepth(200);
                lightning.explode(64);
    
                this.time.delayedCall(30, () => {
                    lightning.explode(32);
                });
                this.time.delayedCall(10, () => {
                    lightning.explode(16);
                });
            
                this.cameras.main.shake(200, 0.02);
    
                this.time.delayedCall(200, () => {
                    lightning.destroy();
                });
            }           	 
        }
        
        const config = {
            type: Phaser.WEBGL,
            parent: 'game',
            scene: [LoadScene, MainScene],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1024,
                height: 1920,
				//width : '100%',
				//height : '100%',
                resolution: Math.max(window.devicePixelRatio || 1, 1),
            },
            cameras: {
                default: {
                    zoom: 1,
                    near: -1000,
                    far: 1000,
                    position: { x: 0, y: 0, z: 100 }
                }
            },
            input: { 
                activePointers: 2 
            },
            fps: { 
                target: 60,
                smoothStep: true 
            },
            render: { 
                antialiasGL: true,
                pixelArt: false
            }
        };

        if (navigator.userAgent.toLowerCase().includes('android')) {
            document.body.style.height = `${window.innerHeight}px`;
            setTimeout(() => {
                document.body.style.height = `${window.innerHeight}px`;
            }, 1000);
        }	   
        
        setTimeout(() => {
            game = new Phaser.Game(config);
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∏–≥—Ä—ã
            if (tg)
			checkOrientation();
            
            window.addEventListener('resize', () => {
                if (game && game.scale) {
                    game.scale.refresh();
                }
                if (tg)
				checkOrientation(); // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
            });
        }, 300);
        
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>